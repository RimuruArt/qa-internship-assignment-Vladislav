# Теоретическая часть


```markdown
# theory.md

## Основы тестирования

**Что такое тестирование ПО?**  
Тестирование программного обеспечения (ПО) — это систематический процесс проверки соответствия фактического поведения системы требованиям и ожиданиям пользователя. Цель тестирования — выявить дефекты в ПО до передачи его конечному пользователю. Например, при тестировании формы входа мы проверяем, что при вводе правильного логина и пароля система авторизует пользователя, а при вводе неправильных данных — показывает сообщение об ошибке.

**Какие существуют виды тестирования?**  
Существует множество видов тестирования:  
- *Функциональное тестирование* проверяет, что система выполняет требуемые функции (что делает система). Например, проверка кнопок, ссылок, форм, бизнес-логики.  
- *Нефункциональное тестирование* оценивает параметры работы системы (как она работает): производительность, надежность, безопасность, удобство использования и т.д.  
- *Регрессионное тестирование* проводится после изменений в коде, чтобы убедиться, что новая функциональность не сломала старую.  
- *Интеграционное тестирование* проверяет взаимодействие между модулями или системами.  
- *Системное тестирование* оценивает систему целиком.  
- *Smoke-тестирование* (smoke) — проверка базовой функциональности после сборки, чтобы убедиться в отсутствии критических проблем.  
- *Приемочное тестирование* (Acceptance) — проверка системы командой заказчика на соответствие бизнес-требованиям.  

Например, после добавления новой функции «Сброс пароля» регрессионные тесты помогут убедиться, что процесс регистрации и входа по-прежнему работает корректно, а функциональное тестирование проверит непосредственно сам процесс сброса пароля.

**В чем разница между валидацией и верификацией?**  
- *Верификация (verification)* — проверка того, что продукт разработан правильно с точки зрения технических требований и спецификации. Она отвечает на вопрос «Делаем ли мы продукт правильно?». К примерам верификации относятся код-ревью, статический анализ, проверка соответствия кода архитектурным решениям.  
- *Валидация (validation)* — проверка того, что продукт удовлетворяет потребности пользователя и решает правильную задачу. Она отвечает на вопрос «Делаем ли мы правильный продукт?». К примерам валидации относятся пользовательское тестирование, приёмочное тестирование, опросы пользователей.  

Например, мы можем верифицировать (проверять) алгоритм шифрования с точки зрения корректности реализации, а валидировать — оценивать, соответствует ли функция обмена зашифрованными сообщениями требованиям заказчика и удобна ли пользователю.

**Какие методологии тестирования вы знаете?**  
Методологии (или модели) разработки ПО определяют подход к организации процесса разработки и тестирования:  
- *Waterfall* (каскадная модель) — этапы разработки идут строго последовательно: требования → дизайн → реализация → тестирование → поддержка. Изменения на поздних этапах затруднены.  
- *Agile* — гибкая методология, ориентированная на итеративную разработку и непрерывное тестирование. Команда разбивает работу на небольшие итерации, регулярно поставляет работающий функционал.  
- *Scrum* — одна из Agile-методологий. Работа делится на спринты (обычно 2–4 недели). В начале спринта определяются задачи, в конце — демонстрация результата. Существует ежедневный Scrum-митинг для синхронизации.  
- *Kanban* — методология, основанная на визуализации задач (например, доска Kanban) и непрерывном потоке задач без фиксированных спринтов. Акцент на ограничении незавершённой работы и быстрой поставке.  
- *DevOps* — подход, объединяющий разработку и эксплуатацию. Включает непрерывную интеграцию и доставку (CI/CD), автоматизацию сборок, тестов и деплоя.  

Например, при использовании Scrum команда каждую неделю планирует конкретные задачи и в конце спринта интегрирует новые функции, проводя при этом регрессионное тестирование, чтобы убедиться, что изменения не нарушили старый функционал.

**Чем отличается функциональное тестирование от нефункционального?**  
- *Функциональное тестирование* проверяет **то, что система должна делать** — то есть соответствие поведению системы её спецификации и требованиям. Примеры: проверка кнопок, форм, бизнес-процессов. Например, проверка, что кнопка «Добавить в корзину» действительно добавляет товар.  
- *Нефункциональное тестирование* проверяет **характеристики работы системы** (производительность, надежность, удобство, безопасность и т.д.), а не конкретную логику. Например, нагрузочное тестирование проверяет, сколько пользователей одновременно выдержит сайт, тест безопасности проверяет устойчивость к взлому, юзабилити-тестирование оценивает удобство интерфейса.  

**В чем разница между позитивным и негативным тестированием?**  
- *Позитивное тестирование* использует корректные, ожидаемые данные и сценарии. Оно проверяет, что система работает **как задумано в нормальных условиях**. Например, ввод валидного логина и пароля и успешный вход в аккаунт.  
- *Негативное тестирование* использует **некорректные или граничные данные**. Оно проверяет, как система обрабатывает ошибки и нестандартные ситуации. Например, ввод неполного email (`test@`) или слишком длинного текста, и проверка появления сообщений об ошибках.  

Позитивное тестирование отвечает на вопрос «Работает ли система при нормальных условиях?», а негативное — «Как система ведёт себя при ошибочных или экстремальных вводах?».

**Что такое регрессионное тестирование и зачем оно нужно?**  
Регрессионное тестирование выполняется после каждого изменения в коде (исправления бага или добавления новой фичи), чтобы убедиться, что ранее работавший функционал не сломался. Обычно регрессионные тесты повторно прогоняют критичные сценарии приложения. Например, после исправления бага в форме заказа прогон регрессионных тестов удостоверится, что оформление нового заказа по-прежнему работает корректно и ничего не поломалось. Регрессия экономит время и предупреждает неожиданные сбои в уже проверенных функциях.

**Что такое тестирование «черного ящика» и «белого ящика»?**  
- *Тестирование «черного ящика» (black-box)* проводится без знания внутренней структуры системы. Тестировщик видит только интерфейс (входы/выходы) и требования, и проверяет приложение «снаружи». Он формулирует сценарии на основе спецификаций и пользовательских кейсов, не погружаясь в код. Например, проверка веб-формы авторизации без просмотра исходников.  
- *Тестирование «белого ящика» (white-box)* проводится с учётом внутренней структуры и кода. Тестировщик (или разработчик) анализирует код, пишет юнит-тесты функций, проверяет покрытие условных ветвлений. Например, тестирование функции расчёта скидки путём проверки всех логических веток в коде. Белый ящик позволяет глубже проверить внутреннюю логику, но требует знания кода.

## Тестовая документация

**Какие виды тестовой документации вы знаете?**  
Основные виды тестовой документации:  
- *Тест-план* (Test Plan) — документ, описывающий объём и стратегию тестирования проекта: цели, ресурсы, расписание, критерии входа/выхода, риски.  
- *Тест-кейсы* (Test Cases) — детальные сценарии тестирования функционала с пошаговым описанием действий и ожидаемым результатом.  
- *Чек-листы* (Checklists) — упрощённые списки пунктов для проверки без подробных шагов.  
- *Отчёт о тестировании* (Test Report) — сводка о проделанной работе: сколько проведено тестов, сколько выявлено дефектов, их статус и выводы.  
- *Баг-репорты* — отчёты о найденных дефектах (см. ниже).  
- *Среда тестирования* (Test Environment) — описание конфигурации тестовой среды, версий ПО, данных.  
- Другие: матрица трассировки требований, схемы, диаграммы и пр.

**Что такое тест-кейс? Из чего он состоит?**  
Тест-кейс — это описанный сценарий проверки функциональности. Структура тест-кейса обычно включает:  
- **ID** — уникальный номер тест-кейса (например, TC-001).  
- **Название** — краткое описание цели теста.  
- **Предусловия** — что должно быть выполнено или настроено перед началом (например, «Пользователь авторизован»).  
- **Шаги** — последовательность действий для проведения теста.  
- **Ожидаемый результат** — что должно произойти согласно требованиям после выполнения шагов.  
- **Фактический результат** — что получилось на самом деле (заполняется после исполнения теста).  
- **Статус** — результат теста (Passed/Failed или Пройден/Не пройден).  
- **Тип теста** — например, Позитивный/Негативный, Регрессионный, UI и т.д.  

**Чем тест-кейс отличается от чек-листа?**  
- *Тест-кейс* описывает сценарий подробно: содержит конкретные шаги, ожидания и данные. Это формальный документ для воспроизводимого тестирования.  
- *Чек-лист* — краткий список проверок без детальных инструкций. Он удобен для быстрой проверки и при небольшом времени. В чек-листе обычно перечисляются условия или элементы, которые нужно проверить (например, «Проверить, что при неверном пароле появляется сообщение об ошибке»), без подробного развертывания действий.

**Что такое тестовый план и что он должен содержать?**  
Тестовый план — документ, определяющий подход к тестированию всего проекта. Обычно включает:  
- **Объект тестирования** (какой продукт).  
- **Объём и цели тестирования**.  
- **Типы тестирования**, которые будут проведены (функциональные, регрессионные, нагрузочные и т.д.).  
- **Критерии входа/выхода** (что должно быть готово перед началом тестирования и что считать завершением).  
- **Ресурсы и расписание** (кто будет тестировать, на каких устройствах, в какие сроки).  
- **Окружение** (серверы, ОС, данные).  
- **Риски и допущения**.  
Например, в тест-плане может быть указано, что до начала тестирования должна быть готова тестовая сборка и есть доступ к базе данных, а тестирование считается завершённым, если критических багов не обнаружено или все они исправлены.

**Как задокументировать найденный дефект?**  
При обнаружении дефекта создаётся баг-репорт. В нём указывают:  
- **Заголовок (Summary)** — краткое описание проблемы.  
- **Описание (Description)** — подробности того, что не работает и при каких условиях.  
- **Шаги воспроизведения** — пошаговое руководство, как повторить дефект.  
- **Ожидаемый результат** — что должно было произойти.  
- **Фактический результат** — что произошло на самом деле.  
- **Серьёзность (Severity)** — как сильно дефект влияет на работу (критично, серьезно или нет).  
- **Приоритет (Priority)** — насколько срочно баг нужно исправить (High, Medium, Low).  
- **Окружение (Environment)** — браузер, ОС, версия приложения и т.д.  
- **Скриншоты/логи** — доказательства проблемы.  
Каждый дефект оформляется отдельно (например, как `BUG-XXX`). В примерах ниже представлены такие баг-репорты.

**Какие атрибуты включает баг-репорт?**  
Типичный баг-репорт включает: ID (например, BUG-001), заголовок, описание, шаги воспроизведения, ожидаемый и фактический результат, приоритет, серьёзность, статус (новый, в работе, закрыт и т.д.), среда тестирования и прикреплённые файлы (скриншоты). Этот набор полей обеспечивает полное понимание проблемы разработчиком и менеджерами.

**Как определить приоритет и серьёзность бага?**  
- **Серьёзность (Severity)** показывает влияние дефекта на работу системы:  
  - *Критическая (Critical)* — приводят к краху системы или потере данных.  
  - *Высокая (Major)* — существенный функционал не работает, но система остаётся работоспособной.  
  - *Средняя (Normal)* — дефект влияет на удобство использования, есть обходные пути.  
  - *Низкая (Minor/Trivial)* — опечатки, косметические проблемы, незначительные ошибки в тексте.  
- **Приоритет (Priority)** определяет порядок исправления:  
  - *Высокий (High)* — баг нужно починить как можно скорее (например, перед релизом).  
  - *Средний (Medium)* — исправление важно, но может подождать.  
  - *Низкий (Low)* — проблема не блокирует функционал и исправляется позже.  

Например, опечатка в тексте на несущественной странице — низкая серьёзность и низкий приоритет. А сбой при оформлении заказа — высокая серьёзность и высокий приоритет.

## SQL и базы данных

**Какие SQL-операторы вы знаете?**  
Основные SQL-операторы для работы с данными:  
- `SELECT` — выборка данных из таблицы (`SELECT * FROM users;`).  
- `INSERT` — добавление новой строки (`INSERT INTO users (name, email) VALUES ('Иван','ivan@example.com');`).  
- `UPDATE` — обновление существующих записей (`UPDATE users SET email='new@example.com' WHERE id=5;`).  
- `DELETE` — удаление записей (`DELETE FROM users WHERE id=10;`).  
- `JOIN` — объединение строк из нескольких таблиц по условию.  
- `WHERE` — фильтрация результатов по условию (`WHERE age > 18`).  
- `GROUP BY` — группировка результатов (часто с агрегатными функциями).  
- `ORDER BY` — сортировка результатов.  
- `LIMIT`/`TOP` — ограничение числа строк в результате.  

**Как с помощью SQL можно отфильтровать данные по определённому условию?**  
Для фильтрации используется оператор `WHERE`. Например:  
```sql
SELECT * 
FROM orders 
WHERE amount > 100;
